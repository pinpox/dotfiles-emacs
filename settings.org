* General options
  This is my literate Emacs configuration. I have copied, adapted and integrated
  parts from more sources than I can keep track of. I keep changing this file
  as I find new tools and redifine my workflows. I'd like to thank all
  the people how published there configurations, snippets and insights and helped me starting out with
  emacs and fixing probems I encountered, but I'm sure I'll forget someone.
  Instead I'll do the same and share this file aswell in the hope that someone
  can profit from it.

  #+BEGIN_QUOTE
  Sharing is good, and with digital technology, sharing is easy.
  -- Richard Stallman
  #+END_QUOTE

** Personal information
   Start by setting some personal information. It is used in tools like git when
   creating commits. I use password-store as my goto-password-manager, emacs
   supports it without plugins since version 26.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq user-full-name "Pablo Ovelleiro Corral"
           user-mail-address "pablo1@mailbox.org"
           mail-host-address "mailbox.org"
           mail-default-reply-to "pablo@mailbox.org")

     (require 'auth-source-pass)
     (auth-source-pass-enable)
   #+END_SRC

** Memory Management

   Let's allow more than 800 KiB cache before starting garbage collection. Every
   time memory crosses a certain threshold, it garbage collects. But the
   default value for this threshold is quite low by modern standards. Another
   low threshold is hit when opening files with sizes that are common nowadays
   and Emacs warns you about being wary of opening such a large file. I
   increase that limit too. I have RAM to spare.

   #+BEGIN_SRC emacs-lisp
   (setq gc-cons-threshold 50000000)
   (setq large-file-warning-threshold 100000000)
   #+END_SRC

** Default encoding (UTF-8)
   Use UTF-8 by default. I don't see why utf-8 should not be used everywhere as
   most systems support it.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (prefer-coding-system        'utf-8)
     (set-language-environment    'utf-8)
     (set-default-coding-systems  'utf-8)
     (set-terminal-coding-system  'utf-8)
     (set-selection-coding-system 'utf-8)
   #+END_SRC

** Package management and use-package

   Emacs becomes truly useful with its package manager and thousands of freely
   available packages from its wonderful community. Use-package is a utility
   library that lets us declaratively setup the packages we will be using. From
   here-on out =use-package= loads packages.

   #+BEGIN_SRC emacs-lisp
     (require 'package)
     (setq package-enable-at-startup nil)
     (setq package-archives '(("org" . "http://orgmode.org/elpa/")
                              ("melpa" . "http://melpa.org/packages/")
                              ("melpa-stable" . "http://stable.melpa.org/packages/")
                              ("gnu" . "https://elpa.gnu.org/packages/")))
     (package-initialize)

     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))

     (eval-when-compile
       (require 'use-package))

     (setq use-package-always-ensure t)
   #+END_SRC

** Other behaviour
   Asking for confirmation when closing an unsaved file seems like a good idea.
   But entering 'y' or 'n' is enough

   #+BEGIN_SRC emacs-lisp
   (defalias 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

   I like starting in the same place in a file as I left it on the next visit

   #+BEGIN_SRC emacs-lisp
  (setq-default save-place t)
  (setq save-place-file "~/.emacs.d/saveplace")
   #+END_SRC

   If you type part of keybind, Emacs will display this part in the echo area after
   a timeout. One second is a bit too long though for my taste.

   #+BEGIN_SRC emacs-lisp
   (setq echo-keystrokes 0.1)
   #+END_SRC

   Save clipboard data of other programs in the kill ring when possible

   #+BEGIN_SRC emacs-lisp
  (setq save-interprogram-paste-before-kill t)
   #+END_SRC

   The way emacs cleans up seaching hightlight confuses me. With this setting it
   behaves more like vim's search and =:noh= also works as expected.

   #+BEGIN_SRC emacs-lisp
    (setq lazy-highlight-cleanup nil)
   #+END_SRC

   Some settings to start with a notes org-mode file. I have disabled them for now
   as I like the rather useless but good-looking dashboard

   #+BEGIN_SRC emacs-lisp
    ;; (setq remember-notes-initial-major-mode 'org-mode)
    ;; (setq remember-data-file "~/org/notes.org")
    ;; (setq initial-buffer-choice 'remember-notes)
   #+END_SRC

** Load additional functions

   I have acumulated a few custom functions and little helpers over time. Some I
   just want to test for a while or don't consider them important enough to add
   theme here. Load them now to be able to bind them later.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path "~/emacs.d/lisp")
     (require 'custom-functions)
   #+END_SRC

** Backups
   Backup files are created on save in the same directory as the file and end in
   ~. They can be numbered which makes most sense combined with a different save
   location and automatic pruning. Autosave files are created between saves after
   a sufficient timeout in the current directory for crash detection, they begin
   and end with #. Let’s change their save location as well.
   #+BEGIN_SRC emacs-lisp
     (setq backup-directory-alist '((".*" . "~/.emacs.d/backup"))
           version-control t
           delete-old-versions t
           auto-save-list-file-prefix "~/.emacs.d/autosave/"
           auto-save-file-name-transforms '((".*" "~/.emacs.d/autosave/" t)))
   #+END_SRC

** Indentation and whitespace

   Establish an indentation and whitespace standard I follow. When coming to
   tabs vs. spaces for indentation, there is literally a [[https://www.jwz.org/doc/tabs-vs-spaces.html][war]] going on. I prefer
   tabs for most languages, lisp excluded.

   To be able to define the indentation-style on per-language basis, here are to
   interactive functions, which can be called manually or in a hook to set the
   style for a buffer or a language. The size of tabs is extracted into a
   variable, so I set it once and use it as needed.

   #+BEGIN_SRC emacs-lisp :tangle yes
     ;; Create a variable for our preferred tab width
     (setq custom-tab-width 4)

     ;; Two callable functions for enabling/disabling tabs in Emacs
     (defun disable-tabs () (setq indent-tabs-mode nil))
     (defun enable-tabs  ()
       (local-set-key (kbd "TAB") 'tab-to-tab-stop)
       (setq indent-tabs-mode t)
       (setq tab-width custom-tab-width))
   #+END_SRC

   I set tabs as default and then revert the setting for those languages on
   which I want spaces.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'prog-mode-hook 'enable-tabs)

     (add-hook 'lisp-mode-hook 'disable-tabs)
     (add-hook 'emacs-lisp-mode-hook 'disable-tabs)
     (add-hook 'org-mode-hook 'disable-tabs)

     ;; Language-Specific Tweaks
     (setq-default python-indent-offset custom-tab-width) ;; Python
     (setq-default js-indent-level custom-tab-width)      ;; Javascript

     ;; Making electric-indent behave sanely
     (setq-default electric-indent-inhibit t)

     ;; Make the backspace properly erase the tab instead of
     ;; removing 1 space at a time.
     (setq backward-delete-char-untabify-method 'hungry)

     ;; Shift width for evil-mode: vim-like motions of ">>" and "<<".
     (setq-default evil-shift-width custom-tab-width)
   #+END_SRC

   To display indentation guides I use [[https://github.com/DarthFennec/highlight-indent-guides][highlight-indent-guides]]. It seems to work
   well with any indentation style and looks fancy with some settings.

   #+BEGIN_SRC emacs-lisp
     (use-package highlight-indent-guides
       :config
       (setq highlight-indent-guides-delay 0)
       (setq highlight-indent-guides-method 'character)
       ;; (setq highlight-indent-guides-character ?\┆) ;; Indent character samples: | ┆ ┊
       (setq highlight-indent-guides-responsive 'top)
       (add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
       (add-hook 'org-mode-hook 'highlight-indent-guides-mode))
   #+END_SRC

   Lastly some sane defaults. Trailing whitespace is deleted on save and I set
   the fill-collum to 80, which breaks up line while typing after the 80th
   character. The last line fixes the strange behaviour of the backspace key of
   deleting tabs only one space at a time. Pressing backspace on a tab should
   delete it.

   #+BEGIN_SRC emacs-lisp
     (setq whitespace-style '(face trailing))
     (global-whitespace-mode)
     (setq show-trailing-whitespace t
           sentence-end-double-space nil
           default-fill-column 80)
     (add-hook 'before-save-hook 'delete-trailing-whitespace)
     (setq backward-delete-char-untabify-method 'hungry)
   #+END_SRC

** Scrolling
   Default scrolling settings confuse me, as I keep loosing the line on which the
   point is. Setting the scroll margin higher scrolls "sooner" and gives a bit
   more context.
   #+BEGIN_SRC emacs-lisp
     (setq-default scroll-margin 5
                   scroll-conservatively 0
                   scroll-up-aggressively 0.01
                   scroll-down-aggressively 0.01)
   #+END_SRC

** Remote editing
   If TRAMP makes backup files, they should better be kept locally than remote.
   Also setting the default tramp method to =ssh= has solved some problems for
   me on specific servers.

   #+BEGIN_SRC emacs-lisp
     (setq tramp-backup-directory-alist backup-directory-alist)
     (customize-set-variable 'tramp-default-method "ssh")
   #+END_SRC

** Buffers
   Auto revert mode looks for changes to files and updates them for you. With
   these settings, dired buffers are also updated. The last setting makes sure
   that you're not alerted every time this happens. Which is every time you
   save something.

   #+BEGIN_SRC emacs-lisp
     (global-auto-revert-mode 1)
     (setq global-auto-revert-non-file-buffers t
           auto-revert-verbose nil)
   #+END_SRC

   A function I find useful: Kill all other buffers (except the current one). I
   Bind this to a key in general, as I use it quite a lot.

   #+BEGIN_SRC emacs-lisp
     (defun kill-other-buffers ()
       "Kill all other buffers."
       (interactive)
       (mapc 'kill-buffer
             (delq (current-buffer)
                   (remove-if-not 'buffer-file-name (buffer-list)))))
   #+END_SRC

* Evil

  The extensible vi layer for Emacs. As a vim-refugee I try to enable evil-mode
  in as many places as I can.

** [[https://github.com/emacs-evil/evil][evil-mode]]
   Ensure the evil-mode package is installed. I don't do much configuration here
   apart from remapping =:= and =;=. I never saw the point of having to press
   =Shift= to enter commands, swiching this keys completely makes more sense to
   me.

   #+BEGIN_SRC emacs-lisp
     (use-package evil
       :ensure t
       :init
       (setq evil-want-integration t)
       (setq evil-want-keybinding nil)
       :config (progn
                 (evil-mode 1)                                                         ;; Enable evil mode everywhere
                 (define-key evil-normal-state-map (kbd ";") 'evil-ex)                 ;; Swap ; and : for easier command entering (normal mode)
                 (define-key evil-visual-state-map (kbd ";") 'evil-ex)                 ;; Swap ; and : for easier command entering (visual mode)
                 (define-key evil-motion-state-map (kbd ":") 'evil-repeat-find-char))) ;; I don't use this much, but map it for completeness


       (evil-define-key 'normal 'global "/" 'swiper)

     ;; (with-eval-after-load 'evil-maps
     ;;   (define-key evil-insert-state-map (kbd "RET") 'newline-and-indent))
   #+END_SRC

** [[https://github.com/emacs-evil/evil-collection][evil-collection]]

   More evil-mode keybindings, more evil-mode, more evil. There are parts that
   evil-mode doesn't cover on it's own like =help-mode= or =calendar=, this
   makes evil's keybindings more consistent.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-collection
       :after evil
       :ensure t
       :custom
       (evil-collection-setup-minibuffer t)
       :config (setq evil-collection-mode-list (delete 'dired evil-collection-mode-list))
       (evil-collection-init))
   #+END_SRC

** [[https://github.com/Somelauw/evil-org-mode][evil-org]]

   I also want evil bindings for org-mode. Why shouldn't I?

   #+BEGIN_SRC emacs-lisp
     (use-package evil-org
       :ensure t
       :after org
       :after evil
       :config
       (add-hook 'org-mode-hook 'evil-org-mode)
       (add-hook 'evil-org-mode-hook
                 (lambda ()
                   (evil-org-set-key-theme)))
       (require 'evil-org-agenda)
       (evil-org-agenda-set-keys))
   #+END_SRC

** [[https://github.com/emacs-evil/evil-magit][evil-magit]]

   Evil keybingings for magit

   #+BEGIN_SRC emacs-lisp :tangle yes
         (use-package evil-magit)
   #+END_SRC

** [[https://github.com/linktohack/evil-commentary][evil-commentary]]

   Toggle comments in evil-mode. I used the similar vim-plugin for a long time,
   so this is muscle-memory. No need to learn it from scratch, the keybindings
   are the same.

   #+BEGIN_SRC emacs-lisp
     (use-package evil-commentary
       :after evil
       :ensure t
       :config
       (evil-commentary-mode))
   #+END_SRC

** [[https://github.com/cofi/evil-numbers][evil-numbers]]

   Another vim-inspired package. I have disabled it for now, since what I really
   want is something like [[https://github.com/triglav/vim-visual-increment][vim-visual-increment]]. One day I might implement that
   functionality and submit a pull-request or create a fork of the package.

   #+BEGIN_SRC emacs-lisp
     ;; (use-package evil-numbers
     ;;    :ensure
     ;;    :config
     ;;    (define-key evil-normal-state-map (kbd "C-A")
     ;;   'evil-numbers/inc-at-pt)
     ;; (define-key evil-normal-state-map (kbd "C-S-A")
     ;;   'evil-numbers/dec-at-pt)
     ;; )
   #+END_SRC


* Language server protocol

  Taken from the [[https://microsoft.github.io/language-server-protocol/][Official page for Language server]]: The idea behind the Language
  Server Protocol (LSP) is to standardize the protocol for how such servers and
  development tools communicate. This way, a single Language Server can be
  re-used in multiple development tools, which in turn can support multiple
  languages with minimal effort.

  In emacs I use [[https://github.com/emacs-lsp/lsp-mode][lsp-mode]] together with [[https://github.com/emacs-lsp/lsp-ui][lsp-ui]] (higher level UI modules) and
  [[https://github.com/tigersoldier/company-lsp][company-lsp]] (integration for my autocompletion package)

  #+BEGIN_SRC emacs-lisp
    (use-package lsp-mode
      :ensure t
      :init (setq lsp-inhibit-message t
                  lsp-eldoc-render-all nil
                  lsp-highlight-symbol-at-point nil))

    (add-hook 'after-init-hook #'global-flycheck-mode)
    (use-package company-lsp
      :after  company
      :ensure t
      :config
      (setq company-lsp-enable-snippet t
            company-lsp-cache-candidates t))


    (use-package lsp-ui
      :ensure t
      :config
      (setq lsp-ui-sideline-enable t
            lsp-ui-sideline-show-symbol t
            lsp-ui-sideline-show-hover t
            lsp-ui-flycheck-enable t
            lsp-ui-imenu-enable t
            ;; lsp-ui-doc-enable nil
            ;; lsp-ui-sideline-ignore-duplicate t
            lsp-ui-sideline-show-code-actions t
            lsp-ui-sideline-update-mode 'point))


    (add-hook 'lsp-mode-hook 'lsp-ui-mode)

    ;; Enable LSP for some languages
    (add-hook 'python-mode-hook #'lsp)
    (add-hook 'go-mode-hook #'lsp)
    (add-hook 'java-mode-hook #'lsp)

    ;; Enable flycheck-mode to display flycheck diagnostics
    (add-hook 'go-mode-hook 'flycheck-mode)
    (add-hook 'python-mode-hook 'flycheck-mode)
    (add-hook 'java-mode-hook 'flycheck-mode)
  #+END_SRC

** [[https://github.com/emacs-lsp/lsp-java][lsp-java]]

   lsp-mode support for java
   #+BEGIN_SRC emacs-lisp
   (use-package lsp-java
     :ensure t
     :after lsp
     :config (add-hook 'java-mode-hook 'lsp))
   #+END_SRC

* File-types
** config-general-mode, general unix files
   #+BEGIN_SRC emacs-lisp
     (use-package config-general-mode
       :ensure t
       :mode ("\\.conf$" "\\.*rc$" ".ini"))

     (use-package ssh-config-mode
       :ensure t
       :mode ("/\\.ssh/config\\'" "/system/ssh\\'" "/sshd?_config\\'" "/known_hosts\\'" "/authorized_keys2?\\'")
       :hook (ssh-config-mode . turn-on-font-lock)
       :config
       (autoload 'ssh-config-mode "ssh-config-mode" t))

     (use-package logview
       :ensure t
       :mode ("syslog\\(?:\\.[0-9]+\\)" "\\.log\\(?:\\.[0-9]+\\)?\\'"))

     (use-package yaml-mode
       :ensure t
       :mode (".yaml$"))

     (use-package yaml-tomato
       :ensure t)

     (use-package vimrc-mode
       :ensure t
       :mode ("^\\.vimrc\\'"))
   #+END_SRC

** graphviz
   #+BEGIN_SRC emacs-lisp
     (use-package graphviz-dot-mode
       :ensure t
       :init
       (defvar default-tab-width nil)
       :mode ("\\.dot\\'"))
   #+END_SRC

** Latex Export

   Most times I use latex it will have some kind of code-blocks in it. I almost
   always want code syntax-highlighting and use the =minted= package for it.
   Some additional options are passed to the latex command, which is set to
   =xelatex=.

   #+BEGIN_SRC emacs-lisp
     (require 'ox-latex)
     (add-to-list 'org-latex-packages-alist '("" "minted"))
     (setq org-latex-listings 'minted)
     (setq org-latex-pdf-process
           '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
     (setq org-latex-minted-options
           '(("frame" "lines") ("breaklines" "true")  ("frame" "single") ))
   #+END_SRC


* Completion and snippets
** [[https://github.com/abo-abo/swiper][ivy/swiper/counsel]]

   Use ivy for selecting things, also add recent files and bookmarks to the list
   and set a custom date format. Enabling =virtual-buffers= shows recent files
   (=recentf=mode=) and bookmarks too. To stop the suggestions being littered
   with backup and autosave files, I ignore filenames beginning with =#= or
   ending with =#= or =~=.

   I set the matching algorithm to fuzzy (using flx) everywhere except in
   swiper. When searching in files I most often am looking for a particular string

   #+BEGIN_SRC emacs-lisp
     (use-package ivy
       :ensure t
       :config
       (ivy-mode)
       (setq ivy-display-style 'fancy
             ivy-format-function 'ivy-format-function-line ; Make highlight extend all the way to the right
             ivy-use-virtual-buffers t
             ivy-count-format "[%d/%d] "
             enable-recursive-minibuffers t
             ivy-use-selectable-prompt t)


       (setq counsel-find-file-ignore-regexp
             (concat
              "\\(?:\\`[#.]\\)"
              "\\|\\(?:\\`.+?[#~]\\'\\)")))



     (setq ivy-re-builders-alist
           '((swiper . ivy--regex-plus)
             (t      . ivy--regex-fuzzy)))



   #+END_SRC


   #+BEGIN_SRC emacs-lisp

(setq ivy-height-alist
      '((t
         lambda (_caller)
         (/ (frame-height) 3))))

   #+END_SRC

   Ivy-rich displays additional information for the items in ivy. I use mostly
   the default configuration for it for now, but there is more room for customization
   and improvement here.

   #+BEGIN_SRC emacs-lisp
     (use-package ivy-rich
       :ensure t
       :after ivy
       :init
       (setq ivy-rich-path-style 'abbrev
             ivy-virtual-abbreviate 'full)
       :config
       (setq ivy-rich-display-transformers-list

             '(ivy-switch-buffer
               (:columns
                ((ivy-rich-candidate (:width 50))  ; return the candidate itself
                 (ivy-rich-switch-buffer-size (:width 7))  ; return the buffer size
                 (ivy-rich-switch-buffer-indicators (:width 4 :face error :align right)); return the buffer indicators
                 (ivy-rich-switch-buffer-major-mode (:width 20 :face warning))          ; return the major mode info
                 (ivy-rich-switch-buffer-project (:width 20 :face success))             ; return project name using `projectile'
                 (ivy-rich-switch-buffer-path (:aligtn right :width (lambda (x) (ivy-rich-switch-buffer-shorten-path x (ivy-rich-minibuffer-width 0.3))))))  ; return file path relative to project root or `default-directory' if project is nil
                :predicate
                (lambda (cand) (get-buffer cand)))
               counsel-M-x
               (:columns
                ((counsel-M-x-transformer (:width 40))  ; thr original transfomer
                 (ivy-rich-counsel-function-docstring (:face font-lock-doc-face))))  ; return the docstring of the command
               counsel-describe-function
               (:columns
                ((counsel-describe-function-transformer (:width 40))  ; the original transformer
                 (ivy-rich-counsel-function-docstring (:face font-lock-doc-face))))  ; return the docstring of the function
               counsel-describe-variable
               (:columns
                ((counsel-describe-variable-transformer (:width 40))  ; the original transformer
                 (ivy-rich-counsel-variable-docstring (:face font-lock-doc-face))))  ; return the docstring of the variable
               counsel-recentf
               (:columns
                ((ivy-rich-candidate (:width 0.8)) ; return the candidate itself
                 (ivy-rich-file-last-modified-time (:face font-lock-comment-face)))) ; return the last modified time of the file
               counsel-projectile-switch-project
               (:columns
                ((ivy-rich-candidate)))
               counsel-projectile-find-file
               (:columns
                ((ivy-rich-file-icon)
                 (counsel-projectile-find-file-transformer))
                counsel-projectile-find-dir
                (:columns
                 ((ivy-rich-file-icon)
                  (counsel-projectile-find-dir-transformer))
                 ))))
       (ivy-rich-mode 1))

     (setq ivy-format-function #'ivy-format-function-line)
   #+END_SRC


** [[https://github.com/lewang/flx][flx]]

   I use flx which provides a better fuzzy matching algorithm for ivy. The
   details are explained on it's GitHub page, all I can say is: it works better
   for me. Setting =ivy--regex-fuzzy= splits each character with a wild card.
   Searching for "for" returns all "f.*o.*r" matches, resulting in a large
   number of hits. Ivy sorts such large lists using flx package's scoring
   mechanism automatically, if installed.

   #+BEGIN_SRC emacs-lisp
     (use-package flx
       :ensure t
       :config
       (setq ivy-initial-inputs-alist nil))
   #+END_SRC

** [[https://github.com/company-mode/company-mode][company-mode]]
   Modular in-buffer completion framework for Emacs
   #+BEGIN_SRC emacs-lisp

     ;; (use-package company-go
     ;;   :ensure t
     ;;   :defer t
     ;;   :init
     ;;   (with-eval-after-load 'company
     ;; (add-to-list 'company-backends 'company-go)))

     (use-package company
       :ensure t
       :config
       (progn
         (setq company-idle-delay 0.2
               company-selection-wrap-around t
               company-dabberv-downcase 0
               company-minimum-prefix-length 1
               company-show-numbers t
               company-tooltip-limit 20)
         (company-tng-configure-default)
         (define-key company-active-map [tab] nil)
         (define-key company-active-map (kbd "TAB") nil)
         )

       ;; Facing
       (unless (face-attribute 'company-tooltip :background)
         (set-face-attribute 'company-tooltip nil :background "black" :foreground "gray40")
         (set-face-attribute 'company-tooltip-selection nil :inherit 'company-tooltip :background "gray15")
         (set-face-attribute 'company-preview nil :background "black")
         (set-face-attribute 'company-preview-common nil :inherit 'company-preview :foreground "gray40")
         (set-face-attribute 'company-scrollbar-bg nil :inherit 'company-tooltip :background "gray20")
         (set-face-attribute 'company-scrollbar-fg nil :background "gray40"))


       ;; Activating globally
       (global-company-mode t)



       (use-package company-quickhelp
         :ensure t
         :after company
         :config
         (company-quickhelp-mode 1))

       (use-package company-quickhelp          ; Documentation popups for Company
         :ensure t
         :defer t
         :init (add-hook 'global-company-mode-hook #'company-quickhelp-mode)
         )
         )



          (push 'company-lsp company-backends)
   #+END_SRC


** [[https://github.com/joaotavora/yasnippet][yasnippet]]
   A template system for Emacs
   #+BEGIN_SRC emacs-lisp

     (use-package yasnippet
       :ensure t
       :config
       (progn

         ;; (define-key yas-minor-mode-map (kbd "tab") #'yas-expand)

         ;; Activate global
         (yas-global-mode)))

     (use-package yasnippet-snippets :ensure t)
     (use-package ivy-yasnippet :ensure t)

     (defvar company-mode/enable-yas t
       "Enable yasnippet for all backends.")

     (defun company-mode/backend-with-yas (backend)
       (if
           (or (not company-mode/enable-yas)
               (and (listp backend) (member 'company-yasnippet backend))
               )
           backend
         (append (if (consp backend) backend (list backend))
                 '(:with company-yasnippet))))
     (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))
   #+END_SRC

* Org-Mode
  #+BEGIN_SRC emacs-lisp
    (defun ck/org-confirm-babel-evaluate (lang body)
      (not (or (string= lang "latex") (string= lang "dot"))))
    (setq org-confirm-babel-evaluate 'ck/org-confirm-babel-evaluate)

    (add-hook 'org-mode-hook '(lambda () (setq fill-column 80)))
    (add-hook 'org-mode-hook 'turn-on-auto-fill)

    (org-babel-do-load-languages
     'org-babel-load-languages
     '((dot . t))) ; this line activates dot

    (load-library "find-lisp")
    (setq org-agenda-files
          (find-lisp-find-files "~/org-files" "\.org$"))
  #+END_SRC
** [[https://github.com/sabof/org-bullets][org-bullets]]
   Make the bullets in org-mode look nicer with UTF-8 characters
   #+BEGIN_SRC emacs-lisp
   (setq org-cycle-separator-lines 0)
   (use-package org-bullets
     :demand
     :config
     (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

   #+END_SRC

* Linting, spellcheck and reformatting
** [[https://github.com/flycheck/flycheck][flycheck]]
   On the fly syntax checking
   #+BEGIN_SRC emacs-lisp
   (use-package flycheck
     :ensure t
     :init (global-flycheck-mode))
   #+END_SRC
** [[https://github.com/lassik/emacs-format-all-the-code][format-all]]
   Auto-format source code in many languages with one command
   #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package format-all
      :ensure t)
   #+END_SRC

* Other tools
  #+BEGIN_SRC emacs-lisp
(setq langtool-language-tool-jar "/usr/share/java/languagetool/languagetool-commandline.jar")

  #+END_SRC
** [[https://github.com/politza/pdf-tools][pdf-tools]]
   #+BEGIN_SRC emacs-lisp :tangle yes

     (use-package pdf-tools
       :ensure t
       :config
       (pdf-tools-install)
       (setq-default pdf-view-display-size 'fit-page)
       ;; (bind-keys :map pdf-view-mode-map
       ;;     ("\\" . hydra-pdftools/body)
       ;;     ("<s-spc>" .  pdf-view-scroll-down-or-next-page)
       ;;     ("g"  . pdf-view-first-page)
       ;;     ("G"  . pdf-view-last-page)
       ;;     ("l"  . image-forward-hscroll)
       ;;     ("h"  . image-backward-hscroll)
       ;;     ("j"  . pdf-view-next-page)
       ;;     ("k"  . pdf-view-previous-page)
       ;;     ("e"  . pdf-view-goto-page)
       ;;     ("u"  . pdf-view-revert-buffer)
       ;;     ("al" . pdf-annot-list-annotations)
       ;;     ("ad" . pdf-annot-delete)
       ;;     ("aa" . pdf-annot-attachment-dired)
       ;;     ("am" . pdf-annot-add-markup-annotation)
       ;;     ("at" . pdf-annot-add-text-annotation)
       ;;     ("y"  . pdf-view-kill-ring-save)
       ;;     ("i"  . pdf-misc-display-metadata)
       ;;     ("s"  . pdf-occur)
       ;;     ("b"  . pdf-view-set-slice-from-bounding-box)
       ;;     ("r"  . pdf-view-reset-slice)
       ;; )
     (use-package org-pdfview :ensure t))
   #+END_SRC

** [[https://magit.vc/][magit]]
   #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package magit
         :ensure t
         :defer t
         ;; :bind (("C-x g" . magit-status))
         ;; :config
         ;; (progn
     ;;       (defun inkel/magit-log-edit-mode-hook ()
     ;;   (setq fill-column 72)
     ;;   (flyspell-mode t)
     ;;   (turn-on-auto-fill))
     ;;       (add-hook 'magit-log-edit-mode-hook 'inkel/magit-log-edit-mode-hook)
     ;;       (defadvice magit-status (around magit-fullscreen activate)
     ;;   (window-configuration-to-register :magit-fullscreen)
     ;;   ad-do-it
     ;;   (delete-other-windows))
     ;;
     ;; )
         )
   #+END_SRC

** [[https://github.com/dgutov/diff-hl][diff-hl]]
   Show git diff gutter
   #+BEGIN_SRC emacs-lisp
   (use-package diff-hl
 :ensure t
 :config
 (global-diff-hl-mode +1)
 (add-hook 'dired-mode-hook 'diff-hl-dired-mode)
 (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))
   #+END_SRC

** [[https://github.com/justbur/emacs-which-key][which-key]]
   Emacs package that displays available keybindings in popup
   #+BEGIN_SRC emacs-lisp
   (use-package which-key :demand)
   (which-key-mode)
   #+END_SRC
** [[https://github.com/bbatsov/projectile][projectile]]
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package projectile
       :bind-keymap
       ;; ("C-c p" . projectile-command-map)
       :config
       (setq projectile-project-search-path '("~/Projects/" "~/Documents/" "~/org-files")))
     (projectile-mode +1)
   #+END_SRC
** [[https://github.com/ericdanan/counsel-projectile][counsel-projectile]]
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package counsel-projectile
       :ensure t
       :config
       (counsel-projectile-mode))
   #+END_SRC

** [[https://github.com/DarwinAwardWinner/amx][amx]]
   #+BEGIN_SRC emacs-lisp
     (use-package amx :defer 0.5
       :config (amx-mode))
   #+END_SRC
* Keybindings
  I really like the idea of a leader key for custom bindings. More generally
  (pun intended) I like the =general.el= package a lot, as I can define them
  without having to worry too much about replacing something that is already
  bound to that key. I took a few ideas from spacemacs (namely using =SPC= for
  my leader) and bind all keys to mnemonics that make sense to me. In
  combination with which-key I find them easy to remember and instead of just
  using spacemacs I can keep addingrthe ones I really need.

** [[https://github.com/noctuid/general.el][general.el]]
   More convenient key definitions in emacs
   #+BEGIN_SRC emacs-lisp
     (use-package general
       :ensure t
       :init
       (setq general-override-states '(insert
                                       emacs
                                       hybrid
                                       normal
                                       visual
                                       motion
                                       operator
                                       replace))


       :config
       (general-define-key
        :states '(normal visual insert emacs motion)
        :keymaps 'override
        :prefix "SPC"
        :non-normal-prefix "M-SPC"
        ;; General stuff
        "SPC"  '(counsel-M-x :which-key "M-x")
        "ESC"  'keyboard-quit
        "/"  '(counsel-ag :wich-key "ag")
        "."  '(avy-goto-word-or-subword-1  :which-key "go to word")
        ;; "a" '(hydra-launcher/body :which-key "Applications")
        "c"  '(:ignore t :which-key "comment")
        "cl" '(comment-or-uncomment-region-or-line :which-key "comment line")
        ;; "w" '(hydra-window/body :which-key "Window")

        ;; Files
        "f"  '(:ignore t :which-key "files")
        "fd" '(counsel-git :which-key "find in git dir")
        "ff" '(counsel-find-file :which-key "open file")
        "fr" '(counsel-recentf :which-key "recent-files")
        ;; Configs
        "fc" '(:ignore t :which-key "Config")
        "fc" '(:ignore t :which-key "Config")

        ;; "fce" '(:ignore t :which-key "Config") TODO edit emacs settings org

        ;; Applicartions
        "a"  '(:ignore t :which-key "Applications")
        "g"  '(:ignore t :which-key "Git")
        "gs" '(magit-status :which-key "Git status")


        ;; Org
        "o"  '(:ignore t :which-key "Org")
        "ol" '(org-toggle-link-display :which-key "Toggle link visibility")
        "ov" '(visible-mode :which-key "Toggle visibility")

        ;; Windows
        "w"  '(:ignore t :which-key "Window")
        "wo" '(delete-other-windows :which-key "delete other windows")
        "wd" '(delete-window :which-key "delete window")
        "ws" '(split-window-right :which-key "split vertical")
        "wS" '(split-window-below :which-key "split horizontal")

        ;; Buffers TODO edit, eval..
        "b"  '(:ignore t :which-key "Buffer")
        "bo" '(kill-other-buffers :which-key "Kill other buffers")
        "bd" '(kill-buffer-and-window :which-key "kill buffer and window")
        "TAB"  '(ivy-switch-buffer :which-key "switch buffer")
        "b=" '(format-all-buffer :which-key "Cleanup current buffer")


        ;; Projects
        "p" '(:ignore t :which-key "Project")
        "pp" '(counsel-projectile-switch-project :which-key "Switch project")
        "pf" '(counsel-projectile-find-file :which-key "Project file")
        "p/" '(counsel-projectile-ag :which-key "Search project")



        ))
   #+END_SRC
* Work Tools
  Some services I'm forced to use and integrate into emacs.
** Wiki
   #+BEGIN_SRC emacs-lisp
     (use-package dokuwiki
       :ensure t
       :defer t
       :config
       (setq dokuwiki-xml-rpc-url "http://192.168.3.132/dokuwiki/lib/exe/xmlrpc.php")
       (setq dokuwiki-login-user-name "povelleiro"))
   #+END_SRC

** Jira
   #+BEGIN_SRC emacs-lisp
     (use-package org-jira
       :ensure t
       :defer t
       :config
       (setq jiralib-url "https://desk.committance.com")
       )
   #+END_SRC

* Spellcheck
  #+BEGIN_SRC emacs-lisp

(when (executable-find "hunspell")
  (setq-default ispell-program-name "hunspell")
  (setq ispell-really-hunspell t))

;; easy spell check
(global-set-key (kbd "<f8>") 'ispell-word)
(global-set-key (kbd "S-<f8>") 'flyspell-buffer)
(defun flyspell-check-next-highlighted-word ()
  "Custom function to spell check next highlighted word"
  (interactive)
  (flyspell-goto-next-error)
  (ispell-word)
  )
(global-set-key (kbd "M-<f8>") 'flyspell-check-next-highlighted-word)

(eval-after-load "flyspell"
  '(progn
     (defun flyspell-goto-next-and-popup ( )
       "Goto the next spelling error, popup menu, and stop when the end of buffer is reached."
       (interactive)
       (while (< (point) (point-max))
     (flyspell-goto-next-error)
     (redisplay)
     (flyspell-correct-word-before-point))
       (message "No more spelling errors in buffer.")
       )
     ))
(define-key flyspell-mode-map (kbd "C-<f8>") 'flyspell-goto-next-and-popup)

  #+END_SRC
* Eshell

  A shamelessly copied snippet do make the emacs-shell look a bit nicer. Still
  have to get the line-numbers to disappear

  #+BEGIN_SRC emacs-lisp
(require 'cl)
(require 'dash)
(require 's)

(defmacro with-face (STR &rest PROPS)
  "Return STR propertized with PROPS."
  `(propertize ,STR 'face (list ,@PROPS)))

(defmacro esh-section (NAME ICON FORM &rest PROPS)
  "Build eshell section NAME with ICON prepended to evaled FORM with PROPS."
  `(setq ,NAME
         (lambda () (when ,FORM
                 (-> ,ICON
                    (concat esh-section-delim ,FORM)
                    (with-face ,@PROPS))))))

(defun esh-acc (acc x)
  "Accumulator for evaluating and concatenating esh-sections."
  (--if-let (funcall x)
      (if (s-blank? acc)
          it
        (concat acc esh-sep it))
    acc))

(defun esh-prompt-func ()
  "Build `eshell-prompt-function'"
  (concat esh-header
          (-reduce-from 'esh-acc "" eshell-funcs)
          "\n"
          eshell-prompt-string))

(esh-section esh-dir
             "\xf07c"  ;  (faicon folder)
             (abbreviate-file-name (eshell/pwd))
             '(:foreground "gold" :bold ultra-bold :underline t))

(esh-section esh-git
             "\xe907"  ;  (git icon)
             (magit-get-current-branch)
             '(:foreground "pink"))

(esh-section esh-clock
             "\xf017"  ;  (clock icon)
             (format-time-string "%H:%M" (current-time))
             '(:foreground "forest green"))

;; Below I implement a "prompt number" section
(setq esh-prompt-num 0)
(add-hook 'eshell-exit-hook (lambda () (setq esh-prompt-num 0)))
(advice-add 'eshell-send-input :before
            (lambda (&rest args) (setq esh-prompt-num (incf esh-prompt-num))))

(esh-section esh-num
             "\xf0c9"  ;  (list icon)
             (number-to-string esh-prompt-num)
             '(:foreground "brown"))

;; Separator between esh-sections
(setq esh-sep "  ")  ; or " | "

;; Separator between an esh-section icon and form
(setq esh-section-delim " ")

;; Eshell prompt header
(setq esh-header "\n ")  ; or "\n┌─"

;; Eshell prompt regexp and string. Unless you are varying the prompt by eg.
;; your login, these can be the same.
(setq eshell-prompt-regexp " ")   ; or "└─> "
(setq eshell-prompt-string " ")   ; or "└─> "

;; Choose which eshell-funcs to enable
(setq eshell-funcs (list esh-dir esh-git esh-clock esh-num))

;; Enable the new eshell prompt
(setq eshell-prompt-function 'esh-prompt-func)
(add-hook 'shell-mode-hook (lambda ()
                                                          (linum-mode -1)))
  #+END_SRC
* Appearance

  Removes the menu,tool and scrollbars along with the splash-screen.

  #+BEGIN_SRC emacs-lisp
    (menu-bar-mode -1)
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    (setq inhibit-splash-screen t)

    (global-hl-line-mode 1)                                ;; Highlight current line
    (setq-default display-line-numbers 'relative           ;; Display relative line-numbers
                  display-line-numbers-current-absolute t) ;; Show absolute line number for current line
    (show-paren-mode 1)                                    ;; Show matching parenthesis
    (setq show-paren-delay 0)                              ;; Show it immediately, don't delay
  #+END_SRC
** [[https://github.com/TheBB/spaceline][spaceline]]
   Show a nicer mode-line
   #+BEGIN_SRC emacs-lisp
     (use-package spaceline
 :ensure t
 :init
 (require 'spaceline-config)
 (setq spaceline-highlight-face-func 'spaceline-highlight-face-evil-state)
 (setq powerline-default-separator 'slant)
 (setq evil-normal-state-tag "NORMAL")
 (setq evil-insert-state-tag "INSERT")
 (setq evil-visual-state-tag "VISUAL")
 (setq evil-emacs-state-tag "EMACS")
 :config
 (progn
   (                    ;; spaceline-define-segment buffer-id
                     ;;  ( if (buffer-file-name)
                     ;;       (let ((project-root (projectile-project-p)))
                     ;;         (if project-root
                     ;;             (file-relative-name (buffer-file-name) project-root)
                     ;;           (abbreviate-file-name (buffer-file-name))))
                     ;;     (powerline-buffer-id)
                     ;;   )
     )
   (spaceline-spacemacs-theme)
   (spaceline-toggle-minor-modes-off)))
   #+END_SRC
** [[https://github.com/emacs-dashboard/emacs-dashboard][emacs-dashbord]]
   Display a startup dashboard
   #+BEGIN_SRC emacs-lisp
       (use-package dashboard
     :ensure t
     :config
     (dashboard-setup-startup-hook))
     (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
     (setq dashboard-items '((recents  . 5)
         (bookmarks . 5)
         (projects . 5)
         (agenda . 5)
         ;; (registers . 5)
     ))

     (setq dashboard-banner-logo-title "Happy hacking.")        ;; Set the title
     (setq dashboard-startup-banner "~/.emacs.d/pc.png")        ;; Set the banner
     (setq dashboard-center-content t)            ;; Center content
     (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
   #+END_SRC

** [[https://github.com/tarsius/hl-todo][hl-todo]]

   Minor mode for coloring TODO, NOTE, FIXME and many more keywords of
   that sort prevalent in comments and strings.
   #+BEGIN_SRC emacs-lisp
  ;; (use-package hl-todo
  ;; :ensure t
  ;; :config
  ;;  ((setq hl-todo-keyword-faces '(("TODO" . hl-todo)
  ;;                                 ("NOTE" . hl-todo)
  ;;                                 ("HACK" . hl-todo)
  ;;                                 ("FIXME" . hl-todo)
  ;;                                 ("KLUDGE" . hl-todo)))



  ;;   (with-eval-after-load 'hl-todo
  ;;     (hl-todo-set-regexp))
  ;;     (hl-todo-mode)
   #+END_SRC


** [[https://github.com/emacsmirror/rainbow-mode][rainbow-mode]]
   A minor mode for Emacs which displays strings representing colors with the
   color they represent as background.

   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-mode
       :ensure t
       :config
       (add-hook 'prog-mode-hook 'rainbow-mode))
   #+END_SRC

** Themes
   Also install some themes. If I'll be looking at this the whole day, it might
   as well look nice.

*** doom-themes

    #+BEGIN_SRC emacs-lisp
      (use-package doom-themes
        :init
        (load-theme 'doom-one t)
        :config
        (progn
          (doom-themes-neotree-config)
          (doom-themes-org-config)))
      ;; (setq doom-neotree-line-spacing 0)
    #+END_SRC

*** gruvbox
    #+BEGIN_SRC emacs-lisp
       ;; (use-package gruvbox-theme :ensure t :defer t)
       ;; (load-theme 'gruvbox-dark-hard t)
    #+END_SRC



* TODO
*** TODO bind swiper to /
*** TODO evil-textobj-between.el
*** TODO evil-numbers
*** TODO Add keybindings to jira-commands with general
*** TODO use global ensure
*** TODO password-store-el
** Some ideas (taken from https://medium.com/@CBowdon/pinching-the-best-bits-from-spacemacs-869b8c793ad3)
*** TODO Try eglot instaed of lsp-mode https://github.com/cbowdon/Config/blob/master/emacs/init.org
*** TODO A shortcut to edit my init file (a literate init file with Org mode, which is great).
*** TODO One key departure from Spacemacs:
    adding special modes like dired and VC to the evil-emacs-state-map, so that
    it uses the (usually consistent and mnemonic) default key bindings for those
    modes instead of mixing with Evil unpredictably.
*** TODO reference Spacemacs to get ideas for language-specific packages to install.
*** TODO misc
    #+BEGIN_SRC  emacs-lisp
          ;; (defun check-expansion ()
          ;;   (save-excursion
          ;;     (if (looking-at "\\_>") t
          ;;       (backward-char 1)
          ;;       (if (looking-at "\\.") t
          ;;         (backward-char 1)
          ;;         (if (looking-at "->") t nil)))))

          ;; (defun do-yas-expand ()
          ;;   (let ((yas/fallback-behavior 'return-nil))
          ;;     (yas/expand)))

          ;; (defun tab-indent-or-complete ()
          ;;   (interactive)
          ;;   (if (minibufferp)
          ;;       (minibuffer-complete)
          ;;     (if (or (not yas/minor-mode)
          ;;             (null (do-yas-expand)))
          ;;         (if (check-expansion)
          ;;             (company-complete-common)
          ;;           (indent-for-tab-command)))))

          ;; (global-set-key [tab] 'tab-indent-or-complete)
    #+END_SRC
